import numpy as np

def parse_obj_data(obj_data):
    vertices = []
    normals = []
    faces = []

    for line in obj_data.splitlines():
        line = line.strip()

        if line.startswith('v '):
            parts = line.split()
            vertices.append([float(parts[1]), float(parts[2]), float(parts[3])])

        elif line.startswith('vn '):
            parts = line.split()
            normals.append([float(parts[1]), float(parts[2]), float(parts[3])])

        elif line.startswith('f '):
            parts = line.split()
            face_vertices = []
            face_normals = []
            
            for part in parts[1:]:
                v_n = part.split('//')
                vertex_index = int(v_n[0]) - 1  # Convert to 0-based index
                normal_index = int(v_n[1]) - 1  # Convert to 0-based index
                face_vertices.append(vertex_index)
                face_normals.append(normal_index)
            
            faces.append((face_vertices, face_normals))

    return vertices, normals, faces


def reorder_faces_counterclockwise(vertices, faces):
    # Counterclockwise ordering of vertices to match left-hand rule for normal vectors
    def cross_product(v1, v2, v3):
        edge1 = np.array(v2) - np.array(v1)
        edge2 = np.array(v3) - np.array(v1)
        return np.cross(edge1, edge2)

    def is_counterclockwise(v1, v2, v3):
        cp = cross_product(v1, v2, v3)
        return cp[2] > 0  # Z component should be positive for counterclockwise

    ordered_faces = []
    for face in faces:
        face_vertices = face[0]
        v1, v2, v3 = vertices[face_vertices[0]], vertices[face_vertices[1]], vertices[face_vertices[2]]

        # If the vertices are not in counterclockwise order, reverse them
        if is_counterclockwise(v1, v2, v3):
            ordered_faces.append(face)
        else:
            ordered_faces.append((face_vertices[::-1], face[1][::-1]))

    return ordered_faces


def format_obj_data(vertices, normals, faces):
    vertex_strs = [f"Coordinate({v[0]}, {v[1]}, {v[2]}), " for v in vertices]
    face_strs = []

    for i, face in enumerate(faces):
        face_str = "("
        for vertex_index, normal_index in zip(face[0], face[1]):
            face_str += f"{vertex_index}, "  # Use 0-based indexing for the vertices
        face_str += f"), # Face {i}"
        face_strs.append(face_str.strip())

    return "[" + "\n".join(face_strs) + "\n], [" + "\n".join(vertex_strs) + "],"


def main():
    obj_data = """
    # OBJ generated by ONSHAPE BY PTC INC, 1.189 Units = meters
mtllib Part Studio 1 - Part 1.mtl
g Part 1
v 1 0.33 0 
v 1 0 0 
v 0 0 0 
v 0 0.33 0 
v 5.55112e-17 0 1 
v 5.55112e-17 0.33 1 
v 1 0 1 
v 1 0.33 1 
vn 0 0 -1 
vn -1 0 0 
vn 0 0 1 
vn 1 0 0 
vn 0 1 0 
vn 0 -1 0 
usemtl 0.615686_0.811765_0.929412_0.000000_0.000000
o mesh0
f 1//1 2//1 3//1 
f 3//1 4//1 1//1 
o mesh1
f 4//2 3//2 5//2 
f 5//2 6//2 4//2 
o mesh2
f 6//3 5//3 7//3 
f 7//3 8//3 6//3 
o mesh3
f 8//4 7//4 2//4 
f 2//4 1//4 8//4 
o mesh4
f 1//5 4//5 6//5 
f 6//5 8//5 1//5 
o mesh5
f 2//6 7//6 5//6 
f 5//6 3//6 2//6 

    """

    # Step 1: Parse the OBJ data
    vertices, normals, faces = parse_obj_data(obj_data)

    # Step 2: Reorder the faces to ensure counterclockwise winding order
    ordered_faces = reorder_faces_counterclockwise(vertices, faces)

    # Step 3: Format the data as a string
    formatted_obj_data = format_obj_data(vertices, normals, ordered_faces)
    
    # Output the formatted data (can print or return the string)
    print(formatted_obj_data)


if __name__ == '__main__':
    main()
